<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树前序遍历</title>
    <url>/2020/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="二叉树前序遍历"><a href="#二叉树前序遍历" class="headerlink" title="二叉树前序遍历"></a>二叉树前序遍历</h2><ul>
<li>给定一个二叉树，返回它的 前序 遍历</li>
<li>二叉树的前序遍历：按照访问根节点——左子树——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树<h3 id="初始化二叉树"><a href="#初始化二叉树" class="headerlink" title="初始化二叉树"></a>初始化二叉树</h3></li>
<li>[1,null,2,3]<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = (val === <span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="built_in">this</span>.left = (left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left)</span><br><span class="line">    <span class="built_in">this</span>.right = (right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">root.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">root.right.left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="方法1-–-递归"><a href="#方法1-–-递归" class="headerlink" title="方法1 – 递归"></a>方法1 – 递归</h3></li>
<li>按照定义，我们只要首先将 root 节点的值加入答案，然后递归调用 preorder(root.left) 来遍历 root 节点的左子树，最后递归调用 preorder(root.right) 来遍历 root 节点的右子树即可，递归终止的条件为碰到空节点</li>
<li>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次</li>
<li>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    qianxu(root,arr);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qianxu</span>(<span class="params">root, arr</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">root !== <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">        arr.push(root.val);</span><br><span class="line">        qianxu(root.left,arr);</span><br><span class="line">        qianxu(root.right,arr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2-–-迭代"><a href="#方法2-–-迭代" class="headerlink" title="方法2 – 迭代"></a>方法2 – 迭代</h3></li>
<li>设置栈，先进后出，出的根节点把左右子节点已进栈，首先添加右节点再添加左节点，这样可以让左节点先出栈</li>
<li>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次</li>
<li>空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal2 = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">root === <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">stack.length !== <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">        result.push(node.val);</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">node.right</span>)</span>&#123;</span><br><span class="line">            stack.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">node.left</span>)</span>&#123;</span><br><span class="line">            stack.push(node.left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>二叉树算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>算法</tag>
        <tag>力扣每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树后序遍历</title>
    <url>/2020/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h2><ul>
<li>二叉树的后序遍历：按照访问左子树——右子树——根节点的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树<h3 id="方法1-–-递归"><a href="#方法1-–-递归" class="headerlink" title="方法1 – 递归"></a>方法1 – 递归</h3></li>
<li>定义 postorder(root) 表示当前遍历到 root 节点的答案。按照定义，我们只要递归调用 postorder(root-&gt;left) 来遍历 root 节点的左子树，然后递归调用 postorder(root-&gt;right) 来遍历 root 节点的右子树，最后将 root 节点的值加入答案即可，递归终止的条件为碰到空节点</li>
<li>时间复杂度：O(n)，其中 nn 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</li>
<li>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    dfs(arr, root);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">arr, root</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        dfs(arr, root.left);</span><br><span class="line">        dfs(arr, root.right);</span><br><span class="line">        arr.push(root.val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法2-–-迭代"><a href="#方法2-–-迭代" class="headerlink" title="方法2 – 迭代"></a>方法2 – 迭代</h3></li>
<li>设置栈，先进后出，出的左节点把根节点和右节点加进栈，首先添加根节点再添加右节点，这样可以让右节点先出栈</li>
<li>时间复杂度：O(n)，其中 nn 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</li>
<li>空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        stack.push(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">stack.length !== <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            stack.push(<span class="literal">null</span>)</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">root.right</span>)</span>&#123;</span><br><span class="line">            stack.push(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">root.left</span>)</span>&#123;</span><br><span class="line">            stack.push(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(stack.pop().val)</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>[1,null,2,3]</li>
<li>模拟运行</li>
<li>1</li>
<li>1,null,2</li>
<li>1,null,2,null,3</li>
<li>1,null,2,null,3,null</li>
<li>3,2,1</li>
</ul>
]]></content>
      <categories>
        <category>二叉树算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>算法</tag>
        <tag>力扣每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>求根到叶子节点数字之和</title>
    <url>/2020/11/10/%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="求根到叶子节点数字之和"><a href="#求根到叶子节点数字之和" class="headerlink" title="求根到叶子节点数字之和"></a>求根到叶子节点数字之和</h2><ul>
<li>初始化<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化二叉树</span></span><br><span class="line"><span class="comment">//[1,2,3]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = (val === <span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="built_in">this</span>.left = (left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left)</span><br><span class="line">    <span class="built_in">this</span>.right = (right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="方法1-–-深度遍历"><a href="#方法1-–-深度遍历" class="headerlink" title="方法1 – 深度遍历"></a>方法1 – 深度遍历</h3></li>
<li>从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历</li>
<li>时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。</li>
<li>空间复杂度：O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sumNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root,sum</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">root === <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum * <span class="number">10</span> + root.val;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">root.left === <span class="literal">null</span> &amp;&amp; root.right === <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root.left,sum) + dfs(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="方法2-–-广度遍历"><a href="#方法2-–-广度遍历" class="headerlink" title="方法2 – 广度遍历"></a>方法2 – 广度遍历</h3><ul>
<li>初始时，将根节点和根节点的值分别加入两个队列。每次从两个队列分别取出一个节点和一个数字，进行如下操作:<ul>
<li>如果当前节点是叶子节点，则将该节点对应的数字加到数字之和</li>
<li>如果当前节点不是叶子节点，则获得当前节点的非空子节点，并根据当前节点对应的数字和子节点的值计算子节点对应的数字，然后将子节点和子节点对应的数字分别加入两个队列</li>
</ul>
</li>
<li>搜索结束后，即可得到所有叶子节点对应的数字之和</li>
<li>时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。</li>
<li>空间复杂度：O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于队列，每个队列中的元素个数不会超过 n<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sumNumbers2 = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">root === <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> stack1 = [];</span><br><span class="line">    <span class="keyword">let</span> stack2 = [];</span><br><span class="line">    stack1.push(root);</span><br><span class="line">    stack2.push(root.val);</span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">stack1.length !== <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack1.shift();</span><br><span class="line">        <span class="keyword">let</span> num = stack2.shift();</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">node.left !== <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">                stack1.push(node.left);</span><br><span class="line">                stack2.push(node.left.val + num * <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">node.right !== <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">                stack1.push(node.right);</span><br><span class="line">                stack2.push(node.right.val + num * <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>二叉树算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>算法</tag>
        <tag>力扣每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>相同的树</title>
    <url>/2020/11/10/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<h2 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h2><h3 id="初始化二叉树"><a href="#初始化二叉树" class="headerlink" title="初始化二叉树"></a>初始化二叉树</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = (val === <span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="built_in">this</span>.left = (left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left)</span><br><span class="line">    <span class="built_in">this</span>.right = (right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//root[1,null,2,3] root2[1,null,2,3]</span></span><br><span class="line"><span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">root.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">root.right.left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root2 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">root2.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">root2.right.left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="方法1-–-深度遍历"><a href="#方法1-–-深度遍历" class="headerlink" title="方法1 – 深度遍历"></a>方法1 – 深度遍历</h3><ul>
<li>如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同</li>
<li>时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数</li>
<li>空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(p ,q)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">p, q</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">p === <span class="literal">null</span> &amp;&amp; q === <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">p === <span class="literal">null</span> || q === <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">p.val === q.val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(p.left, q.left) &amp;&amp; dfs(p.right, q.right);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="方法2-–-广度遍历"><a href="#方法2-–-广度遍历" class="headerlink" title="方法2 – 广度遍历"></a>方法2 – 广度遍历</h3><ul>
<li>初始时将两个二叉树的根节点分别加入两个队列。每次从两个队列各取出一个节点，进行如下比较操作:<ol>
<li>比较两个节点的值，如果两个节点的值不相同则两个二叉树一定不同</li>
<li>如果两个节点的值相同，则判断两个节点的子节点是否为空，如果只有一个节点的左子节点为空，或者只有一个节点的右子节点为空，则两个二叉树的结构不同，因此两个二叉树一定不同</li>
<li>如果两个节点的子节点的结构相同，则将两个节点的非空子节点分别加入两个队列，子节点加入队列时需要注意顺序，如果左右子节点都不为空，则先加入左子节点，后加入右子节点</li>
</ol>
</li>
<li>时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点数。对两个二叉树同时进行广度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数</li>
<li>空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点数。空间复杂度取决于队列中的元素个数，队列中的元素个数不会超过较小的二叉树的节点数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack1= [];</span><br><span class="line">    <span class="keyword">let</span> stack2 = [];</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">p === <span class="literal">null</span> &amp;&amp; q === <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">p === <span class="literal">null</span> || q === <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        stack1.push(p);</span><br><span class="line">        stack2.push(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">stack1.length !== <span class="number">0</span> &amp;&amp; stack2.length !== <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> node1 = stack1.pop();</span><br><span class="line">        <span class="keyword">let</span> node2 = stack2.pop();</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">node1.val === node2.val</span>)</span>&#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">node1.right &amp;&amp; node2.right</span>)</span>&#123;</span><br><span class="line">                stack1.push(node1.right);</span><br><span class="line">                stack2.push(node2.right);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">node1.left &amp;&amp; node2.left</span>)</span>&#123;</span><br><span class="line">                stack1.push(node1.left);</span><br><span class="line">                stack2.push(node2.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">node1.left === <span class="literal">null</span> ^ node2.left === <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">node1.right === <span class="literal">null</span> ^ node2.right === <span class="literal">null</span></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>二叉树算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>算法</tag>
        <tag>力扣每日一题</tag>
      </tags>
  </entry>
</search>
